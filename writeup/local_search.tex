In previous chapters we introduced the problem of brain parcellation
using fMRI data and show how it can be framed as a graph partitioning
problem on the weighted, undirected voxel graph. Our goal is to find a
valid partitioning of the voxel graph that maximizes the Adjacent-Score
(\ref{adjacent-score}) subject to reasonable criterion values for
Jaggedness (\ref{jaggedness} and Balance (\ref{balance}). A valid
partitioning of the voxel graph $G(V, E)$ is defined as a collection of
disjoint, non-empty, vertex-connected subsets of $V$, interchangeably
called parcels, components, or partitions.

The focus of this chapter is on heuristic methods for finding such
partitionings based on the idea of graph growing. Each algorithm begins
with $|V|$ unconnected vertices and iteratively joins adjacent ones into
components until some stopping criterion is met. Such algorithms have
the property that each iteration produces a valid partitioning.

The main result of this chapter is the Edge-Contract algorithm based on
the Contractible Graph data structure, covered in Sections 4.2 and 4.3.
Section 4.1 discusses the Add-Edge algorithm, the precursor to
Edge-Contract that generated poor parcellations and motivated the
development of the latter.

\section{The Add-Edge Algorithm}

The Add-Edge algorithm has two flavors: Unconstrained and
Size-Constrained. The Unconstrained version starts with an empty graph
with all the vertices $V$ but no edges. It sequentially adds edges
between adjacent voxels in order of highest sample distance
correlation, until the graph has some prespecified number of connected
components $k$.

The biggest issue with the Unconstrained Add-Edge algorithm is that
larger components have a higher probability of the next edge being
added to them, causing the resulting parcellation to be severely
imbalanced parcellations. In the 100-component graph, there was one
component containing over 99.9\% of all the vertices.

Our first attempt to address this problem was to impose a filter on
each edge considered, adding the edge only if at least one of the two
following conditions are met:

\begin{enumerate}[1.]
\item
At least one of the two components bridge by the edge is of size less
than some prespecified parameter $s_{\min}$.

\item
The union of the two components is of size $\leq s_{\max}$.
\end{enumerate}

These two restrictions were not entirely successful in solving the size
imbalance issue. Our successful solution is the Edge-Contract algorithm,
described in the next section.

\section{The Edge-Contraction Algorithm and Contractible Graphs}

We propose a new data structure called the \textit{Contractible Graph}
(CG) for brain parcellation. The rationale behind the CG is a heuristic
procedure for partitioning a graph into somewhat balanced components
so as to maximize the Adjacent-Score (Equation \ref{adjacent-score}).

The CG is a mapping of the vertices of the original graph to the
vertices of a new graph. The vertices of the CG are called
\textit{components} and between any two components there exists exactly
one weighted edge, henceforth called a \textit{link}. The weight
of a link $w_{A,B}$ between two components $A$ and $B$ in the CG equals
the average weight of all edges in the original graph between vertices
mapped to $A$ and vertices mapped to $B$. If no such edges exist,
the weight of the link is $0$. Formally,

\[ E_{A,B} = \{(i, j) \in E : i \in A, j \in B\} \]
\[ w_{A,B} = \begin{cases}
    \frac{1}{|E_{A,B}|} \sum_{(i,j) \in E_{A,B}} w_{ij} &
        \text{if } |E_{A,B}| > 0 \\
    0 & \text{otherwise}
\end{cases} \]

\includegraphics[scale = 0.55]{figs/4_contractible_graph}

We say an edge $(i,j)$ is \textit{between} components $A$ and $B$ if
$i$ is in one of $A$ or $B$ and $j$ is in the other. The \textit{size}
of a component is the number of vertices it contains.
A \textit{contraction} of a link $(A,B)$ in a CG replaces components
$A$ and $B$ with a new component (call it $C$) containing all vertices
mapped to $A$ or $B$, as illustrated in the figure above.
Component $C$ has one link to every other component in the CG, whose
weights are the mean of the weights of the corresponding vertex edges,
or $0$ if no edge exists. Thus the contraction operation maintains the
link-invariant property of CG. This leads to the Edge-Contraction
algorithm, which begins with the original graph with all vertices as
singleton components and contracts edges in a certain order until the
graph has only $k$ components in all.

\begin{algorithm}
\caption{Edge-Contraction}
\begin{algorithmic}
\State \textbf{Input:} Undirected positive-weighted graph $G$ and
       target component number $k$
\State Create a CG from $G$ so that every vertex maps to
       a unique component
\Repeat
\State $\mathcal{S} \gets$ smallest component(s) in the CG
\State $(A,B) \gets \argmax{A \in \mathcal{S}} w(A,B)$
\State Contract $(A,B)$
\Until{CG has $k$ components}
\State \textbf{Output:} Components of CG
\end{algorithmic}
\end{algorithm}

Why does Edge-Contraction work better than the previous algorithms?
The Edge-Contraction algorithm attempts to address two problems of
the Size-Constrained Add-Edge algorithm: unbalanced parcels and poor
Adjacent-Score relative to randomized graph. It solves the former
problem by prioritizing edges that are connected to small components.

The low Adjacent-Score is likely due to the following scenario:
when a vertex is added to a component, it might have multiple
edges to that component. One edge might have a very high weight; this is
the one that is officially ``added''. However, the other edges with far
lower weights are implicitly added as well, lowering the average edge
weights within the component.

The Edge-Contraction algorithm handles this issue by maintaining that
there can be at most one edge between any two components A and B, and
further that the weight on such an edge is the mean of the weights on
all edges that connect a vertex in A with a vertex in B.

\subsection{Implementation using Nested Hash Tables and Priority Queue}

In a Contractible Graph, the weight of the link between two components
depends on the summed weight of all edges between them, and the number
of such edges.

Our implementation of the CG uses \textit{nested hash tables},
diagrammed below. The outer hash table maps each component $A$ to an
inner hash table, which maps all components $B$ with a positive link to
$A$ to 1) the summed weights of the edges and 2) the number of edges
between $A$ and $B$.

\includegraphics[scale = 0.6]{figs/4_cg_implement}

Implementing the contraction of components $B$ and $C$ into a new
component $D$ on this nested hash table requires the following steps.
The time complexity is stated assuming no hash collisions.

\begin{enumerate}
\item
Compute $\mathcal{X}$, the set of all components that either $B$ or $C$
is linked to. $O(|E_B| + |E_C|)$

\item
Create a new element in the outer hash table, $D$, and associate it
with an empty inner hash table. $O(1)$

\item
For each component $X \in \mathcal{X}$,
\begin{itemize}
\item
Retrieve $W(X,B) + W(X,C)$, the summed weights all edges between $X$
and $B$ and between $X$ and $C$, and $|E_{X,B}| + |E_{X,C}|$, the
number of such edges. These quantities are stored explicitly as a
values in the inner hash table, so this operations is $O(1)$.

\item
Add a new component name $D$ to the inner hash table of $X$ and map it
to $\big( W(X,B) + W(X,C), |E_{X,B}| + |E_{X,C}| \big)$. Delete
elements $B$ and $C$ from the inner list of $X$. $O(1)$

\item
In the $D$ inner hash table, add component name $X$ and map it to
to the same $\big( W(X,B) + W(X,C), |E_{X,B}| + |E_{X,C}| \big)$.
$O(1)$
\end{itemize}

\item
Delete $B$ and $C$ from the outer list.
\end{enumerate}

Having described the contraction step, we will next discuss how to
efficiently locate the link to be contracted.
In computer science, a \textit{Maximum Priority Queue} (MaxPQ) data
type is a set of well-ordered objects that supports the following
operations:

\begin{itemize}
\item
\textit{add(obj)}: Adds an object to the set.

\item
\textit{remove\_maximum()}: Removes and returns an object with the
largest priority in the set.
\end{itemize}

Using the heap data structure, the above two operations both run in
$O(\log n)$ time.

Each component on the CG will be associated with an element of the
priority queue. The priority of component $A$ is defined as
\[ \max_{X}\;w_{A,X} - |A| \]
Since our graph link and edge weights are all between 0 and 1, the
highest priority element in the queue always has the smallest size.
Therefore, if the priority queue is up-to-date with the CG, the
next link to be contracted according to Edge-Contraction has
an endpoint component whose priority is the highest in the queue.

However, a complication arises from the fact that a contraction can
change the priorities of components neighboring the contracting
components, thereby making the priorities stored in the MaxPQ
out-of-date. For instance, if components $A$ and $B$ are contracted, and
there is a component $C$ with positive links to both $A$ and $B$, then
the $C-A$ and $C-B$ links will be replaced by a $C-(AB)$ link with a
different weight. If either $C-A$ or $C-B$ links happened to be the
maximum-weighted links of $C$, then $C$'s priority will be lower,
and $C$ ought to be further down the queue.

To address this issue, we could re-compute the priority of every
component drawn from the MaxPQ. If the component's actual priority is
not the maximum, then it is re-inserted into the queue with updated
priority. Additionally, the maximum priority component may no longer
exist in the CG due to contraction with another component. In this case
it is simply discarded.

Without using an efficient priority queue, the linear searching method
of finding the next link to contract results in a $O\big(n (n-k)\big)$
time algorithm. Using the priority queue the time complexity of
Edge-Contraction is $O \big((n - k) (m + \log n)\big)$, where $m$ is
the average number of positive links a component has.

\subsection{Results}

\begin{table}
\caption{Results of Edge-Contract for Different Component Numbers}
\csvautotabular{figs/4_edge_contract_results.csv}
\label{4_ec}
\end{table}

Table (\ref{4_ec}) shows the validation scores of several criteria on
Edge-Contract parcellations to different component numbers.
The Edge-Contract parcellations notably outperformed the 116-parcel
Automatic Anatomical Labeling (AAL) parcellation in the
Adjacency-Score. For further comparison, we found the mean edge weight
in the graph to be 0.7258, which is even slightly higher than the
average adjacent within-parcel edge in AAL. This suggests that the AAL
parcellation has no connection with the functional information
contained in this fMRI data set. It shows on the other hand that the
Edge-Contract algorithm can successfully locate regions of functional
similarity.

The one apparent deficiency of Edge-Contract is the jaggedness of its
parcels. Comparison of our parcellations with the AAL in Table
(\ref{4_ec}) shows that our 116-component parcellation -- the same
number of components as AAL -- has an average parcel surface area
roughly $\big( \frac{92.14}{29.62} \big)^{\frac{2}{3} }\approx 2.11$
times that of AAL. This issue is resolved by the Generalized
Edge-Contract algorithm in the next section.

\section{The Generalized Edge-Contraction Algorithm}

In the original Edge-Contraction algorithm, the criteria for selecting
the next link to contract was to search through the set of smallest
components and find the link of maximal weight. Because this criteria
takes no account of the shape of the two components to be contracted,
the resulting parcels tend to be very jagged.

To address this we expanded the criterion for finding the next link
to contract. Rather than use only the size of the component and the
weight of the link, a \textit{Generalized Edge-Contraction} algorithm
may use any piece of information stored in the Contractible Graph about
a pair of components, such as the number of edges connecting two
components. A \textit{priority function} takes information of any two
components in a CG and outputs a real number, the priority. For each
iteration, the pair of components with the largest priority is
contracted and the priorities of neighboring components with respect
to the newly conjoined component are computed.

For two components $A,B$ let $|A|$ denote size (number of vertices)
of $A$, $E_{A,B}$ denote the set of edges between $A$ and $B$, and
$w_{A,B}$ the weight of the link connecting $A$ and $B$.
The priority function of the original Edge-Contraction algorithm
is $p_0(A, B) = w_{A,B} - |B|$.

\begin{table}
\caption{Results of Generalized Edge-Contract for Various Parameter Settings}
\centering
\begin{subtable}[v]{0.5\textwidth}
  \input{figs/4_gen_ec_116.tex}
  \caption{116 Parcels}
\end{subtable}
~
\begin{subtable}[v]{0.5\textwidth}
  \input{figs/4_gen_ec_300.tex}
  \caption{300 Parcels}
\end{subtable}
\label{gen_ec}
\end{table}

A link $(A, B)$ will have high priority if either component is small,
if the link has a large weight, and if it has a good boundary-ratio,
defined as $\frac{|E_{A,B}|}{\min(|A|,|B|)}$, which helps to minimize
jaggedness. From these notions we created a family of priority
functions indexed by tunable parameters $\alpha$ and $\beta$
\begin{equation} \label{priority_func}
p_1(A, B) = \frac{w_{A,B}^\alpha}{|A|^\beta} \cdot
            \frac{|E_{A,B}|}{\min(|A|,|B|)}
\end{equation}
that modulate the balance of small size, large weight, and high
boundary ratio. Table (\ref{gen_ec}) shows the results of the
116-component and 300-component Generalized Edge-Contract parcellation
when performed for various values of $\alpha$ and $\beta$. The adjacent
scores have fallen on average from 0.79 in the vanilla edge contraact
to 0.75 here. This implies a tradeoff between prioritizing edge weight,
jaggedness, and balance in producing a parcellation.

With a balance score of 0.332, the AAL parcellation was better balanced
than all of the parcellations obtained via this priority function,
though not drastically. In terms of jaggedness, these parcellations
all fell within the vicinity of AAL. In this one brain, the best
parcellation arises from parameters $\alpha = 6$ and $\beta = 4$.

Parcellations of other brains using generalized edge contract can be
found in chapter 8.
